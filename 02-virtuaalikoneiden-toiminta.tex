\section{Virtuaalikoneiden toiminta}

Virtuaalikone on ohjelma, joka tarjoaa todellisen tai hypoteettisen laitteen toiminnallisuuksia muille ohjelmille hyödyntäen sitä suorittavan \textit{isäntäjärjestelmän} abstraktioita. Virtuaalikone voi esimerkiksi virtualisoida optista asemaa käyttämällä isännän tiedostojärjestelmää hyväksi, jolloin virtuaalikoneessa suoritettava ohjelma luulee lukevansa optista levyä, kun todellisuudessa tieto tulee kiintolevyltä. Virtuaalikoneita on kahdenlaisia, \textit{järjestelmä-} ja \textit{prosessivirtuaalikoneita}~\cite[s.~33]{vms}. Järjestelmävirtuaalikone tarjoaa kokonaisen käyttöjärjestelmän palvelut toisin kuin prosessivirtuaalikone, joka tarjoaa vaan yhden prosessin suorittamista varten tarvittavat palvelut.

\subsection{Virtuaalikoneen anatomia}

Tässä tutkielmassa virtuaalikoneella tarkoitetaan korkean tason ohjelmointikielellä toteutetun ohjelman suorittavaa virtuaalikonetta. Tällaiset virtuaalikoneet ovat prosessivirtuaalikoneita. Ohjelma riittää kääntää virtuaalikoneelle, jolloin se toimii kaikilla alustoilla, joille kyseinen virtuaalikone on toteutettu.

Virtuaalikonemalli parantaa myös tietoturvaa. Virtuaalikoneessa suoritettava ohjelma pääsee käsiksi vain virtuaalikoneen tarjoamiin palveluihin, jolloin ohjelmat on helpompi eristää käyttöjärjestelmästä ja laitteistosta~\cite[s.~36]{vms}. Pahan tahtoisen ohjelman on siis löydettävä haavoittuvuus sekä virtuaalikoneesta että sen isännästä.

Ensimmäisen JavaScript-virtuaalikoneen nimi on SpiderMonkey~\cite{spidermonkey}. Se toteutettiin Netscape-selainta varten vuonna 1995 ja nykyään sitä ylläpitää Mozilla ja sitä käytetään muun muassa Mozillan Firefox-selaimessa. Nykyinen SpiderMonkey koostuu kolmesta fundamentaalisesta komponentista: \textit{kääntäjä}, \textit{tulkki} ja \textit{roskienkerääjä}~\cite{spidermonkeydesign}.

Kääntäjä huolehtii koodin \textit{jäsentämisestä} (parsing) ja kääntämisestä \textit{tavukoodiksi}. Virtuaalikoneen tavukoodi on verrattavissa todellisen koneen konekoodiin. Sitä on helpompi käsitellä ohjelmallisesti kuin tekstimuotoista ohjelmakoodia, sillä se on yksinkertaisempaa syntaksiltaan, joskin runsassanaisempaa.

Tulkin tehtävä on suorittaa tavukoodia. Tulkki siis lukee tavukoodia ja tekee tarvittavat toiminnot, jotka riippuvat alustasta. Tulkista on siis oltava oma versionsa jokaista tuettua alustaa varten. Todellisuudessa tulkkia käytetään vain suorituksen alkuvaiheessa keräämään tyyppitietoa. Usein kutsutut, niin sanotut ``kuumat'' funktiot, pyritään kääntämään optimoiduksi konekoodiksi \textit{suorituksenaikaisella kääntäjällä} eli \textit{JIT-kääntäjällä} (Just-In-Time compiler)~[lähde?].

Roskienkerääjän tehtävä on yksinkertaisesti poistaa muistista muuttujat ja oliot, joihin ohjelmassa ei enää viitata. Roskienkerääjän ansiosta ohjelmoijan ei tarvitse vapauttaa muistia itse, vaan järjestelmä hoitaa muistinhallinnan automaattisesti. Automaattinen muistinhallinta vähentää virheiden määrää, kuten muistivuotoja, mutta ei poista kaikkia ongelmia~[lähde?].

\subsection{Esimerkki: V8}

Vuonna 2008 Google julkaisi uuden selaimen, Google Chromen, jonka oli tarkoitus parantaa verkkosovellusten käyttökokemusta~\cite{chromepress}. Googlen kiinnostus käyttökokemuksen parantamisesta on ymmärrettävää, sillä yhtiöllä on paljon verkkopalveluita, jotka hyötyvät hyvästä suorituskyvystä. Näistä syistä Google päätyi toteuttamaan oman JavaScript-virtuaalikoneen V8:n.

Mielenkiintoisen V8:sta tekee se, että siinä ei ole lainkaan tulkkia. Sen sijaan V8 kääntää JavaScript koodin suoraan konekoodiksi ennen suorittamista. SpiderMonkeyn tapaan se kerää tyyppitietoa suorituksen aikana ja käyttää optimoivaa JIT-kääntäjää suorituskyvyn parantamiseksi~\cite{v8compilers}.

%V8:ssa on luonnollisesti myös roskienkerääjä, sillä kielen standardiin kuuluu automaattinen muistinhallinta. Muistinhallinnasta kerrotaan lisää sen suorituskykyä käsittelevässä kappaleessa.

\subsection{Esimerkki: JavaScriptCore}

JavaScriptCore on WebKit-nimisen Web-teknologioita toteuttavan ohjelmistokomponentin JavaScript-virtuaalikone. Apple käyttää WebKitiä ja \mbox{JavaScriptCorea} Safari-selaimessaan.

JavaScriptCore koostuu tulkista, yksinkertaisesta JIT-kääntäjästä sekä Googlen V8:n innoittamana optimoivasta JIT-kääntäjästä, jota he kutsuvat nimellä DFG-JIT. DFG tulee sanoista \textit{Data Flow Graph}, joka kuvaa ohjelman suorituksenaikaisen tyyppitiedon tallentavaa tietorakennetta. Eli kuten aikaisempien esimerkkien kohdalla, virtuaalikone ensin kerää tyyppitietoa ja sitten generoi optimoitua konekoodia~\cite{javascriptcore}.

\subsection{Esimerkki: Chakra}

Tekstiä tähän...

\subsection{JavaScriptin tuomat haasteet}

Kuten aikaisemmista esimerkeistä käy ilmi, virtuaalikoneet eivät voi suoraan generoida optimoitua konekoodia JavaScript-ohjelmista, sillä ei ole tietoa muuttujien tyypeistä. Prosessorin kannalta on hyvin tärkeää tietää tehdäänkö jokin operaatio kokonaisluvuille, liukuluvuille vai kenties merkkijonoille.

Automaattinen roskienkeruu on todella kätevä toiminnallisuus ohjelmoijan kannalta, mutta sen toteuttaminen hyvin on haastavaa. Ohjelman on pysähdyttävä ja käytävä läpi muistin sisältöä ja vapauttaa muistialueita, jotka eivät ole enää käytössä. Selaimen tapauksessa tämä voi aiheuttaa verkkosovelluksen hidastumista ja huonontaa käyttökokemusta, varsinkin jos kyseessä on interaktiivinen toiminto tai animaatio.