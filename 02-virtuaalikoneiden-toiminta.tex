\section{Virtuaalikoneiden toiminta}

Virtuaalikone on ohjelma, joka tarjoaa todellisen tai hypoteettisen laitteen toiminnallisuuksia muille ohjelmille hyödyntäen sitä suorittavan \textit{isäntäjärjestelmän} abstraktioita ja palveluita. Virtuaalikone voi virtualisoida esimerkiksi optista asemaa käyttämällä isännän tiedostojärjestelmää hyväksi, jolloin virtuaalikoneessa suoritettava ohjelma luulee esimerkiksi lukevansa optista levyä, kun todellisuudessa tieto tulee kiintolevyltä.

\subsection{Kahdenlaisia virtuaalikoneita}

Virtuaalikoneita on kahdenlaisia, \textit{järjestelmä-} ja \textit{prosessivirtuaalikoneita}~\cite[s.~33]{vms}. Järjestelmävirtuaalikone tarjoaa kokonaisen käyttöjärjestelmän palvelut toisin kuin prosessivirtuaalikone, joka tarjoaa vaan yhden prosessin suorittamista varten tarvittavat palvelut. Tässä tutkielmassa virtuaalikoneella tarkoitetaan JavaScriptillä toteutettuja ohjelmia suorittavaa prosessivirtuaalikonetta.

Yksi suurimmista virtuaalikoneiden höydyistä on se, että ohjelma tarvitsee kääntää usean alustan sijaan yhdelle virtuaalikoneelle, jolloin se toimii kaikilla niillä alustoilla, joille kyseinen virtuaalikone on toteutettu. Virtuaalikoneessa suoritettava ohjelma pääsee käsiksi vain virtuaalikoneen tarjoamiin palveluihin, jolloin ohjelmat on helpompi eristää isäntäkäyttöjärjestelmästä ja laitteistosta~\cite[s.~36]{vms}. Pahantahtoisen ohjelman on siis löydettävä haavoittuvuus sekä virtuaalikoneesta että isännästä voidakseen aiheuttaa ongelmia.

\subsection{JavaScript-virtuaalikoneen anatomia}

Ensimmäisen JavaScript-virtuaalikoneen nimi on SpiderMonkey~\cite{spidermonkey}. Se toteutettiin Netscape-selainta varten vuonna 1995. Nykyään sitä ylläpitää Mozilla ja sitä käytetään muun muassa Mozillan Firefox-selaimessa. Nykyinen SpiderMonkey on kehittynyt paljon, mutta se koostuu yhä kolmesta fundamentaalisesta komponentista: \textit{kääntäjä}, \textit{tulkki} ja \textit{roskienkerääjä}~\cite{spidermonkeydesign}. Tämän arkkitehtuurin lisäksi on kuitenkin toteutettu muita järjestelmiä suorituskyvyn parantamiseksi.

Kääntäjä huolehtii koodin \textit{jäsentämisestä} (parsing) ja kääntämisestä \textit{tavukoodiksi}. Virtuaalikoneen tavukoodi on verrattavissa todellisen koneen konekoodiin. Tavukoodia on helpompi käsitellä ohjelmallisesti kuin tekstimuotoista ohjelmakoodia, sillä se on yksinkertaisempaa syntaksiltaan, mutta runsassanaisempaa.

Tulkin tehtävä on suorittaa tavukoodia. Tulkki siis lukee tavukoodia käsky kerrallaan ja kutsuu tarvittavia palveluja omassa koodissaan sekä isäntäjärjestelmässään. Tulkista on siis oltava oma versionsa jokaista eri alustaa varten. Yksi tulkin eduista on, että se on joustavampi kuin todellinen prosessori ja siihen voi toteuttaa monimutkaisempia tavukoodikäskyjä.

Roskienkerääjän tehtävä on yksinkertaisesti poistaa muistista muuttujat ja oliot, joihin ohjelmassa ei enää viitata. Roskienkerääjän ansiosta ohjelmoijan ei tarvitse vapauttaa muistia itse, vaan järjestelmä hoitaa muistinhallinnan automaattisesti. Automaattinen muistinhallinta vähentää virheiden määrää, kuten muistivuotoja, mutta ei poista kaikkia ongelmia. Muistivuodot ovat silti mahdollisia.

\subsection{Suoritusaikainen kääntäminen}

Valitettavasti tulkit ovat hitaita, tai ainakin hitaampia kuin haluttaisiin. Riippumatta toteutustavasta, tulkki joutuu aina tekemään useita konekäskyjä yhden tavukoodikäskyn suorittamiseksi~\cite[s.~35]{vms}

Vuonna 2008 Google julkaisi uuden selaimen, Google Chromen, jonka oli tarkoitus parantaa verkkosovellusten käyttökokemusta~\cite{chromepress}. Googlen kiinnostus käyttökokemuksen ja ennen kaikkea suorituskyvyn parantamisesta on ymmärrettävää, sillä yhtiöllä on paljon verkkopalveluita, jotka hyötyvät hyvästä suorituskyvystä. Näistä syistä Google päätyi toteuttamaan Chrome-selaintaan varten oman virtuaalikoneen nimeltään V8.

Mielenkiintoisen V8:sta tekee se, että siinä ei ole lainkaan tulkkia. Sen sijaan V8 kääntää koodin nopeasti suoraan konekoodiksi ennen suorittamista niin sanotulla \textit{lähtötilannekääntäjällä} (baseline compiler)~\cite{v8design}. Nopean kääntämisen saavuttamiseksi se ei tee monimutkaisia optimointeja vielä tässä ensimmäisessä käännösvaiheessa.

V8:n innoittamana muut virtuaalikonetoteutukset ovat muuttaneet toimintaansa siten, että tulkkia käytetään vain suorituksen alkuvaiheessa ja koodi pyritään kääntämään konekoodiksi mahdollisimman nopeasti \textit{suoritusaikaisella kääntäjällä} eli \textit{JIT-kääntäjällä} (Just-In-Time compiler).

Varsinkin usein kutsutut funktiot, eli niin sanotut ``kuumat funktiot'', halutaan kääntää mahdollisimman optimoiduksi konekoodiksi. Tätä varten käytetään erillistä optimoivaa JIT-kääntäjää, joka on hitaampi kuin lähtötilannekääntäjä, mutta tuottaa suorituskykyisempää konekoodia. JavaScript-koodin optimointi osoittautuu kuitenkin hankalaksi.

\subsection{Optimoinnin ongelmat}

Dynaamisesti tyypitetyllä ohjelmointikielellä toteutetusta ohjelmasta generoitu konekoodi vaatii paljon tyyppitarkastuksia ja poikkeustapauksia muuttujien tyypeille. On kuitenkin huomattu, että ohjelmat käyttäytyvät melko ennustettavalla tavalla. Etenkin usein kutsuttuja funktiota kutsutaan usein samankaltaisilla parametreilla.

Virtuaalikoneiden ei kannata suoraan generoida optimoitua konekoodia JavaScript-ohjelmista, sillä niillä ei ole tietoa muuttujien tyypeistä. Prosessorin kannalta on hyvin tärkeää tietää tehdäänkö jokin operaatio kokonaisluvuille, liukuluvuille tai kenties merkkijonoille. Lisäksi ei ole järkevää käyttää paljon aikaa koodin optimointiin, jos se suoritetaan vain muutamia kertoja.

Virtuaalikoneet keräävät tietoa ohjelman käyttäytymisestä sen suorituksen aikana. Tiedon kerääminen hoidetaan usein tulkissa ja V8:n tapauksessa lähtötilannekääntäjä lisää generoituun konekoodiin käskyjä keräämään tietoa ohjelman käyttämistä tyypeistä~\cite{v8compilers}. Tämän profiloinnin ansiosta on helpompi tehdä parempia optimointipäätöksiä.

Avoimen lähdekoodin WebKit-projekti sisältää JavaScriptCore-nimisen virtuaalikoneen, jota käytetään esimerkiksi Applen Safari selaimessa. Java\-Script\-Core koostuu tulkista, yksinkertaisesta JIT-kääntäjästä sekä Googlen V8:n innoittamana optimoivasta JIT-kääntäjästä, jota he kutsuvat nimellä \textit{DFG-JIT}. Lyhenne DFG, joka tulee sanoista \textit{Data Flow Graph}, kuvaa ohjelman suoritusaikaisen tyyppitiedon tallentavaa tietorakennetta. Siis muiden virtuaalikoneiden tapaan JavaScriptCore kerää ensin tyyppitietoa ja generoi sen avulla optimoitua konekoodia~\cite{javascriptcore}.

Automaattinen roskienkeräys on todella kätevä toiminnallisuus ohjelmoijan kannalta, mutta sen toteuttaminen hyvin on haastavaa. Virtuaalikoneen täytyy pysäyttää ohjelman suoritus ja käydä läpi muistin sisältö vapauttaen muistialueita, joihin ei ole enää viittauksia. Selaimen tapauksessa tämä voi aiheuttaa sovelluksen hidastumista. Hidastuminen huonontaa käyttökokemusta etenkin interaktiivisissa sovelluksissa tai animaation aikana.
